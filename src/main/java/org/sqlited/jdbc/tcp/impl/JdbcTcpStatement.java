/*
 * Copyright (c) 2021 little-pan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.sqlited.jdbc.tcp.impl;

import org.sqlited.io.Transfer;
import org.sqlited.jdbc.adapter.StatementAdapter;
import org.sqlited.result.ResultSetMetaData;
import org.sqlited.result.RowIterator;
import org.sqlited.util.IOUtils;
import org.sqlited.util.logging.LoggerFactory;

import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

public class JdbcTcpStatement extends StatementAdapter {
    static final Logger log = LoggerFactory.getLogger(JdbcTcpStatement.class);

    protected final JdbcTcpConnection conn;
    protected final int id;
    protected int fetchSize;

    protected JdbcTcpResultSet resultSet;
    protected long affectedRows;
    protected ResultSet generatedKeys;
    private boolean autoGeneratedKeys;

    public JdbcTcpStatement(JdbcTcpConnection conn, int id) {
        this.conn = conn;
        this.id = id;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        execute(sql, Statement.NO_GENERATED_KEYS);
        return getResultSet();
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return this.resultSet;
    }

    @Override
    public boolean execute(String sql, String[] columnNames)
            throws SQLException {
        int autoGeneratedKeys = getAutoGeneratedKeys(columnNames);
        return execute(sql, autoGeneratedKeys, null, columnNames);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        int autoGeneratedKeys = getAutoGeneratedKeys(columnIndexes);
        return execute(sql, autoGeneratedKeys, columnIndexes, null);
    }

    protected int getAutoGeneratedKeys(int[] columnIndexes) {
        if (columnIndexes != null && columnIndexes.length > 0) {
            return Statement.RETURN_GENERATED_KEYS;
        } else {
            return Statement.NO_GENERATED_KEYS;
        }
    }

    protected int getAutoGeneratedKeys(String[] columnNames) {
        if (columnNames != null && columnNames.length > 0) {
            return Statement.RETURN_GENERATED_KEYS;
        } else {
            return Statement.NO_GENERATED_KEYS;
        }
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys)
            throws SQLException {
        return execute(sql, autoGeneratedKeys, null, null);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        execute(sql);
        return getUpdateCount();
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        execute(sql, autoGeneratedKeys);
        return getUpdateCount();
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        execute(sql, columnIndexes);
        return getUpdateCount();
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        execute(sql, columnNames);
        return getUpdateCount();
    }

    protected boolean execute(String sql, int autoGeneratedKeys,
                              int[] columnIndexes, String[] columnNames)
            throws SQLException {
        Transfer ch = this.conn.ch;
        try {
            Object genColumns = columnIndexes == null?
                    columnNames: columnIndexes;
            // Init
            IOUtils.close(this.resultSet);
            this.resultSet = null;
            this.affectedRows = 0;
            this.autoGeneratedKeys = (RETURN_GENERATED_KEYS == autoGeneratedKeys);
            IOUtils.close(this.generatedKeys);
            this.generatedKeys = null;

            // Send
            ch.write(Transfer.CMD_EXECUTE)
                    .writeInt(this.id)
                    .writeString(sql)
                    .writeInt(autoGeneratedKeys)
                    .writeArray(genColumns)
                    .flush();
            // Read
            final int result = ch.read(true);
            if (Transfer.RESULT_SET == result) {
                this.resultSet = readResultSet(this);
                return true;
            } else {
                long[] a = this.conn.readOK(result);
                this.affectedRows = a[1];
                if (this.autoGeneratedKeys && getUpdateCount() > 0) {
                    readGeneratedKeys();
                }
                return false;
            }
        } catch (IOException e) {
            String s = "Execute statement error";
            throw this.conn.handle(s, e);
        }
    }

    protected void readGeneratedKeys() throws SQLException {
        JdbcTcpConnection conn = this.conn;
        Transfer ch = conn.ch;
        try {
            log.fine("read auto-generated keys");
            int result = ch.read(true);
            if (Transfer.RESULT_SET == result) {
                this.generatedKeys = readResultSet(this);
            } else {
                conn.readOK(result);
            }
        } catch (IOException e) {
            String s = "Retrieves auto-generated keys error";
            throw conn.handle(s, e);
        }
    }

    protected static JdbcTcpResultSet readResultSet(JdbcTcpStatement stmt)
            throws IOException {
        JdbcTcpConnection conn = stmt.conn;
        Transfer ch = conn.ch;
        // - ResultSet status flag
        ch.readInt();
        ResultSetMetaData metaData = readMetaData(ch);
        RowIterator rowItr = readRows(ch, metaData);
        return new JdbcTcpResultSet(conn, stmt, rowItr);
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        if (this.autoGeneratedKeys) {
            ResultSet rs = this.generatedKeys;
            if (rs == null) return emptyGeneratedKeys();
            else return rs;
        } else {
            String s = "Not request generatedKeys";
            throw new SQLException(s, "S1009");
        }
    }

    protected ResultSet emptyGeneratedKeys() {
        ResultSetMetaData meta = ResultSetMetaData.AUTO_GEN_KEYS_META;
        RowIterator rowItr = RowIterator.empty(meta);
        ResultSet rs = new JdbcTcpResultSet(this.conn, this, rowItr);
        return (this.generatedKeys = rs);
    }

    protected static RowIterator readRows(Transfer ch, ResultSetMetaData metaData)
            throws IOException {
        // Format: [row ..., ] null(row end), status
        List<Object[]> rows = new ArrayList<>();
        Object[] row = (Object[])ch.readArray();

        while (row != null) {
            rows.add(row);
            row = (Object[])ch.readArray();
        }
        int status = ch.read(true);
        boolean last = (status & 0x01) == 0x00;

        return new RowIterator(rows, last, metaData);
    }

    protected static ResultSetMetaData readMetaData(Transfer ch)
            throws IOException {
        Object a = ch.readArray();

        if (a == null) {
            return null;
        } else {
            String[] names = (String[])a;
            int[] metas = (int[])ch.readArray();
            String[] typeNames = (String[]) ch.readArray();
            int[] types = (int[]) ch.readArray();
            int[] scales = (int[]) ch.readArray();
            while (ch.readArray() != null);
            int n = metas.length;
            boolean[][] colMetas = new boolean[n][];
            for (int i = 0; i < n; ++i) {
                boolean[] meta = new boolean[3];
                meta[0] = (metas[i] & 0x01) != 0x0;
                meta[1] = (metas[i] & 0x02) != 0x0;
                meta[2] = (metas[i] & 0x04) != 0x0;
                colMetas[i] = meta;
            }
            return new ResultSetMetaData(names, colMetas, typeNames, types, scales);
        }
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        if (rows < 0) throw new SQLException("Fetch size negative: " + rows);
        this.fetchSize = rows;
    }

    @Override
    public int getFetchSize() throws SQLException {
        return this.fetchSize;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return (int)this.affectedRows;
    }

    @Override
    public void close() throws SQLException {
        try {
            Transfer ch = this.conn.ch;
            ch.write(Transfer.CMD_CLOSE_STMT)
                    .writeInt(this.id)
                    .flush();
        } catch (IOException e) {
            String s = "Close statement error";
            throw this.conn.handle(s, e);
        }
    }

}
